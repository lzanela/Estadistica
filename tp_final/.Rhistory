col = c("red", "black",'green'), lty = c(1, 2), lwd = 2)
linearSmooth <- function(X, Y, h){
#núcleo normal
K <- function(u) dnorm(u)
n<- length(X)
col_ones <- rep(1, n)
values <- rep(0, n)
for (i in 1:n) {
#matriz X de la regresión lineal
X_matrix <- cbind(col_ones, X-X[i])
weights <- K((X-X[i]) / h)
W <- diag(weights)
XtWX.inv <- solve(t(X_matrix)%*%W%*%X_matrix)
a0_hat <- (XtWX.inv%*%t(X_matrix)%*%W%*%Y)[1]
values[i] <- a0_hat #resultados de a0 en cada valor de X
}
return(values)
}
est_lin_loc <- linearSmooth(females$HIP.CIRCUMFERENCE, females$BUTTOCK.KNEE.LENGTH, 40)
plot(females$HIP.CIRCUMFERENCE, est_lin_loc)
plot(NULL, xlim = range(females$HIP.CIRCUMFERENCE), ylim = range(c(fit_nw_optimal, est_lin_loc)),
main = "Estimadores Nadaraya-Watson y Lineal Local",
xlab = "Circunferencia de cadera (mm)",
ylab = "Longitud de fémur (mm)")
# Agregar los estimadores al gráfico
lines(sort(females$HIP.CIRCUMFERENCE), fit_nw_optimal[order(females$HIP.CIRCUMFERENCE)], col = "red", lwd = 3)
lines(sort(females$HIP.CIRCUMFERENCE), est_lin_loc[order(females$HIP.CIRCUMFERENCE)], col = "green", lwd = 3)
legend("topleft", legend = c("Nadaraya-Watson", "Estimador Lineal Local"),
col = c("red", "green"), lty = 1, lwd = 2)
dnorm(HIP.CIRCUMFERENCE)
dnorm((HIP.CIRCUMFERENCE- HIP.CIRCUMFERENCE[1])/15)
(HIP.CIRCUMFERENCE- HIP.CIRCUMFERENCE[1])
# Defino el estimador de NW para un x0
nwsmooth <- function(x0, x, y, bandwidth){
# Armo el vector al que le aplico el núcleo normal
vect <- (x - x0)/bandwidth
# Calculo los pesos
weights <- dnorm(vect)
return(sum(weights*y)/sum(weights))
}
nwsmooth(x, x, y, 15)
sapply(x, nwsmooth, x, y, 15)
# Defino el estimador de NW para un x0
nwsmooth <- function(x0, x, y, bandwidth){
# Armo el vector al que le aplico el núcleo normal
vect <- (x - x0)/bandwidth
# Calculo los pesos
weights <- dnorm(vect)
return(sum(weights*y)/sum(weights))
}
# Calculo el leave-one-out CV
cv_nwsmooth <- function(bandwidth, x, y){
# Vector m, con nwsmooth aplicado a x_i en la posición i
m <- sapply(x, nwsmooth, x, y, bandwidth)
# Armo el vector w, que tiene el coeficiente w_i,h en la posición i
arg_matrix <- outer(x, x, "-") * (1/bandwidth)  # Matriz con (x[i]-x[j])/bandwidth en la posición ij
kernel_matrix <- apply(arg_matrix, c(1, 2), dnorm)  # Núcleo normal aplicado a cada posición
column_sums <- colSums(kernel_matrix)  # Sumo las columnas de kernel_matrix, me queda el denominador de w_i,h
gaussian_kernel_0 <- dnorm(0)  # El num de w_i,h para todo i
w <- gaussian_kernel_0 / column_sums  # Consigo w
# vector con error de predicción de m_h^-i en la posición i
errors <- ((y-m)/(1-w))^2
return(mean(errors))
}
# Defino grilla de bandwidths y calculo el error de cv para cada valor de h en la grilla
bandwidths <- 4:24
errors <- sapply(bandwidths, cv_nwsmooth, x = HIP.CIRCUMFERENCE, y = BUTTOCK.KNEE.LENGTH)
# Encuentro el valor mínimo de error y su índice correspondiente
min_error <- min(errors)
min_error_index <- which.min(errors)
best_bandwidth <- bandwidths[min_error_index]
# Calculo la regresión
ordenado <- order(HIP.CIRCUMFERENCE)
y <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, best_bandwidth)
# Grafico
plot(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
pch = 19, col = "light blue")
lines(HIP.CIRCUMFERENCE[ordenado], y, col = "red")
# Ploteo la función objectivo marcando el valor mínimo
plot(bandwidths, errors, type = "b", main = "Leave one out CV Error para nwsmooth vs Bandwidth",
xlab = "Bandwidth", ylab = "CV Error", col = "blue", pch = 19)
# Marca el valor mínimo de error en el plot
points(best_bandwidth, min_error, col = "red", pch = 19, cex = 1.5)
text(best_bandwidth, min_error, labels = paste("Min Error:", round(min_error, 2)), pos = 3, col = "red")
# Calculo la regresión
ordenado <- order(HIP.CIRCUMFERENCE)
y <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, best_bandwidth)
# Grafico
plot(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
pch = 19, col = "light blue")
lines(HIP.CIRCUMFERENCE[ordenado], y, col = "red")
# Ploteo la función objectivo marcando el valor mínimo
plot(bandwidths, errors, type = "b", main = "Leave one out CV Error para nwsmooth vs Bandwidth",
xlab = "Bandwidth", ylab = "CV Error", col = "blue", pch = 19)
# Marca el valor mínimo de error en el plot
points(best_bandwidth, min_error, col = "red", pch = 19, cex = 1.5)
text(best_bandwidth, min_error, labels = paste("Min Error:", round(min_error, 2)), pos = 3, col = "red")
# Calculo la regresión
ordenado <- order(HIP.CIRCUMFERENCE)
y <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, best_bandwidth)
# Grafico
plot(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
pch = 19, col = "light blue")
lines(HIP.CIRCUMFERENCE[ordenado], y, col = "red")
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
# Calculo la regresión
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, best_bandwidth)
# Grafico
plot(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
pch = 19, col = "light blue")
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red")
# Calculo el error de cv para cada valor de h en la grilla
errors <- sapply(bandwidths, cv_leave_one_out, x = HIP.CIRCUMFERENCE, y = BUTTOCK.KNEE.LENGTH)
# Encuentro el valor mínimo de error y su índice correspondiente
min_error <- min(errors)
min_error_index <- which.min(errors)
best_bandwidth <- bandwidths[min_error_index]
# Ploteo la función objectivo marcando el valor mínimo
plot(bandwidths, errors, type = "b", main = "Leave one out CV Error para ksmooth vs Bandwidth",
xlab = "Bandwidth", ylab = "CV Error", col = "blue", pch = 19)
# Marca el valor mínimo de error en el plot
points(best_bandwidth, min_error, col = "red", pch = 19, cex = 1.5)
text(best_bandwidth, min_error, labels = paste("Min Error:", round(min_error, 2)), pos = 3, col = "red")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(BUTTOCK.KNEE.LENGTH, HIP.CIRCUMFERENCE, "normal", bandwidth = ksmooth_best_bandwidth)
knitr::opts_chunk$set(echo = TRUE)
set.seed(1234)
library(ggplot2)
individuals <- read.table("individuals.csv", header = TRUE, sep = ";")
datos_femenino <- subset(individuals, SEX == 2 & HIP.CIRCUMFERENCE != 0 & BUTTOCK.KNEE.LENGTH!=0)
attach(datos_femenino)
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
pch = 19, col = "blue")
# Division de grupos etarios por cuartiles
cuartiles <- quantile(datos_femenino$AGE.IN.MONTHS,probs = c(0,0.25, 0.5, 0.75,1))
datos_femenino$AGE.GROUP <- cut(datos_femenino$AGE.IN.MONTHS,cuartiles,include.lowest = TRUE, labels = c("0-81","82-128","129-168","169, +"))
#Estimacion de medianas
medianas_estimadas <- tapply(datos_femenino$HIP.CIRCUMFERENCE,datos_femenino$AGE.GROUP,median)
# Función para estimación del se de las medianas
estimar_se_mediana <- function (x, B = 1000){
titahatboot <- rep(0,B)
for(i in 1:B){
Xboot <- sample(x,length(x),replace = TRUE)
titahatboot[i] <- median(Xboot)
}
return(sqrt(mean((titahatboot - mean(titahatboot))^2)))
}
# Cálculo de intervalo bootstrap nivel 0.95
intervalos_confianza <- tapply(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$AGE.GROUP, function(x){
se_boot <- estimar_se_mediana(x)
intervalo_boot <- c(median(x) - 1.96*se_boot,median(x) + 1.96*se_boot)
return(intervalo_boot)
})
# Gráfico
# Los siguientes data frames son unicamente creados para generar el plot
df_medianas <- data.frame(
AGE.GROUP = names(medianas_estimadas),
MEDIAN = medianas_estimadas
)
df_intervalos <- data.frame(
AGE.GROUP = names(intervalos_confianza),
INTERVAL = intervalos_confianza
)
df_intervalos$LOWER <- sapply(df_intervalos$INTERVAL, function(x) x[1])
df_intervalos$UPPER <- sapply(df_intervalos$INTERVAL, function(x) x[2])
df_plot <- merge(datos_femenino,merge(df_medianas,df_intervalos,by="AGE.GROUP"),
by="AGE.GROUP")
ggplot(df_plot, aes(x = AGE.GROUP, y = MEDIAN)) +
geom_point(size = 2) +
geom_errorbar(aes(ymin = LOWER, ymax = UPPER), width = 0.2, linewidth = 1) +
scale_y_continuous(limits = c(min(df_plot$LOWER) * 0.95, max(df_plot$UPPER)),
breaks = seq(from = 600, to = 1000, by = 50)) +
labs(title = "Intervalos de Confianza de medianas de HIP.CIRCUMFERENCE\npor grupo etario",
x = "Grupo Etario", y = "HIP.CIRCUMFERENCE") +
theme_minimal() + theme(
plot.title = element_text(hjust = 0.5, face = "bold", size = 14,
margin = margin(10, 0, 10, 0)),
axis.title = element_text(size = 14))
regresion_100 <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = 100)
regresion_50 <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = 50)
plot(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
pch = 19, col = "light blue")
lines(regresion_100, col = "red")
lines(regresion_50, col = "purple")
legend("bottomright", legend = c("Ventana 100", "Ventana 50"), col = c("red", "purple"), lty = 1, cex = 0.8)
# Defino la grilla de bandwidths
bandwidths <- 20:50
# Defino la función de Leave-One-Out-CV
cv_leave_one_out <- function(x, y, bandwidth) {
n <- length(x)
errors <- numeric(n)
for (i in 1:n) {
# Ajusto el modelo
y_hat <- ksmooth(x[-i], y[-i], "normal", bandwidth = bandwidth, x.points = x[i])$y
# Calculo el mse y lo agrego a errors
mse <- (y[i] - y_hat)^2
errors[i] <- mse
}
return(mean(errors))
}
# Calculo el error de cv para cada valor de h en la grilla
errors <- sapply(bandwidths, cv_leave_one_out, x = HIP.CIRCUMFERENCE, y = BUTTOCK.KNEE.LENGTH)
# Encuentro el valor mínimo de error y su índice correspondiente
min_error <- min(errors)
min_error_index <- which.min(errors)
ksmooth_best_bandwidth <- bandwidths[min_error_index]
# Ploteo la función objectivo marcando el valor mínimo
plot(bandwidths, errors, type = "b", main = "Leave one out CV Error para ksmooth vs Bandwidth",
xlab = "Bandwidth", ylab = "CV Error", col = "blue", pch = 19)
# Marca el valor mínimo de error en el plot
points(ksmooth_best_bandwidth, min_error, col = "red", pch = 19, cex = 1.5)
text(ksmooth_best_bandwidth, min_error, labels = paste("Min Error:", round(min_error, 2)), pos = 3, col = "red")
# Defino el estimador de NW para un x0
nwsmooth <- function(x0, x, y, bandwidth){
# Armo el vector al que le aplico el núcleo normal
vect <- (x - x0)/bandwidth
# Calculo los pesos
weights <- dnorm(vect)
return(sum(weights*y)/sum(weights))
}
# Calculo el leave-one-out CV
cv_nwsmooth <- function(bandwidth, x, y){
# Vector m, con nwsmooth aplicado a x_i en la posición i
m <- sapply(x, nwsmooth, x, y, bandwidth)
# Armo el vector w, que tiene el coeficiente w_i,h en la posición i
arg_matrix <- outer(x, x, "-") * (1/bandwidth)  # Matriz con (x[i]-x[j])/bandwidth en la posición ij
kernel_matrix <- apply(arg_matrix, c(1, 2), dnorm)  # Núcleo normal aplicado a cada posición
column_sums <- colSums(kernel_matrix)  # Sumo las columnas de kernel_matrix, me queda el denominador de w_i,h
gaussian_kernel_0 <- dnorm(0)  # El num de w_i,h para todo i
w <- gaussian_kernel_0 / column_sums  # Consigo w
# Vector con error de predicción de m_h^-i en la posición i
errors <- ((y-m)/(1-w))^2
return(mean(errors))
}
# Defino grilla de bandwidths y calculo el error de cv para cada valor de h en la grilla
bandwidths <- 4:24
errors <- sapply(bandwidths, cv_nwsmooth, x = HIP.CIRCUMFERENCE, y = BUTTOCK.KNEE.LENGTH)
# Encuentro el valor mínimo de error y su índice correspondiente
min_error <- min(errors)
min_error_index <- which.min(errors)
nwsmooth_best_bandwidth <- bandwidths[min_error_index]
# Ploteo la función objectivo marcando el valor mínimo
plot(bandwidths, errors, type = "b", main = "Leave one out CV Error para nwsmooth vs Bandwidth",
xlab = "Bandwidth", ylab = "CV Error", col = "blue", pch = 19)
# Marca el valor mínimo de error en el plot
points(nwsmooth_best_bandwidth, min_error, col = "red", pch = 19, cex = 1.5)
text(nwmooth_best_bandwidth, min_error, labels = paste("Min Error:", round(min_error, 2)), pos = 3, col = "red")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(BUTTOCK.KNEE.LENGTH, HIP.CIRCUMFERENCE, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "purple")
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red")
lines(recta_cuad_min, col = "brown")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(BUTTOCK.KNEE.LENGTH, HIP.CIRCUMFERENCE, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "purple")
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red")
lines(recta_cuad_min$fitted.values, col = "brown")
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("purple", "red", "brown"), lty = 1, cex = 0.8)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(BUTTOCK.KNEE.LENGTH, HIP.CIRCUMFERENCE, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "purple")
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red")
abline(recta_cuad_min$fitted.values, col = "brown")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(BUTTOCK.KNEE.LENGTH, HIP.CIRCUMFERENCE, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(HIP.CIRCUMFERENCE, ksmoothfit, col = "purple")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(HIP.CIRCUMFERENCE, ksmoothfit, col = "purple")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "purple")
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red")
abline(recta_cuad_min$fitted.values, col = "brown")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "blue", lwd = 10)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 10)
abline(recta_cuad_min$fitted.values, col = "brown", lwd = 10)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "blue", lwd = 10)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 10)
abline(recta_cuad_min, col = "brown", lwd = 10)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = 1, cex = 0.8)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "blue", lwd = 4)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 4)
abline(recta_cuad_min, col = "brown", lwd = 4)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = 1, cex = 0.8)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "blue", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
abline(recta_cuad_min, col = "brown", lwd = 3)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = 1, cex = 0.8)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 3, lty = 2)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = 1, cex = 0.8)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 3, lty = 2)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = c(2,1,1), cex = 0.8)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 3, lty = 2)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = c(2,1,1), cex = 0.8, lwd = 3)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 2, lty = 2)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = c(2,1,1), cex = 0.8, lwd = 3)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 2, lty = 2)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = c(2,1,1), cex = 0.8, lwd = c(2,3,3))
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 2, lty = 2)
legend("bottomright", legend = c("ksmooth(41)", "nwsmooth(15)", "lm"), col = c("blue", "red", "brown"), lty = c(2,1,1), cex = 0.8, lwd = c(2,3,3))
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 2)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 2, lty = 2)
legend("bottomright", legend = c("ksmooth(41)", "nwsmooth(15)", "lm"), col = c("blue", "red", "brown"), lty = c(2,1,1), cex = 0.8, lwd = c(2,3,3))
