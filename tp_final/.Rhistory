<<<<<<< HEAD
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'gaussian'), kernel = "gaussian", adjust = 0.5)
ggplot() +
geom_histogram(aes(x = Perim_cef, y = after_stat(density)), binwidth = 1) + geom_density(aes(x = Perim_cef, y = after_stat(density)), col = "green", kernel = "rectangular", adjust = 0.5) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'epanechnikov'), kernel = "epanechnikov", adjust = 0.5) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'gaussian'), kernel = "gaussian", adjust = 0.5)
ggplot() +
geom_histogram(aes(x = Perim_cef, y = after_stat(density)), binwidth = 1) + geom_density(aes(x = Perim_cef, y = after_stat(density)), col = 'green', kernel = "rectangular", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'epanechnikov'), kernel = "epanechnikov", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'gaussian'), kernel = "gaussian", adjust = 2)
ggplot() +
geom_histogram(aes(x = Perim_cef, y = after_stat(density)), binwidth = 1, col = 'grey') + geom_density(aes(x = Perim_cef, y = after_stat(density)), col = 'rectangular', kernel = "rectangular", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'epanechnikov'), kernel = "epanechnikov", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'gaussian'), kernel = "gaussian", adjust = 2)
scale_color_manual(values = c(epanechnikov = 'green', gaussian = 'blue'))
ggplot() +
geom_histogram(aes(x = Perim_cef, y = after_stat(density)), binwidth = 1, col = 'grey') + geom_density(aes(x = Perim_cef, y = after_stat(density)), col = 'rectangular', kernel = "rectangular", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'epanechnikov'), kernel = "epanechnikov", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'gaussian'), kernel = "gaussian", adjust = 2)
ggplot() +
geom_histogram(aes(x = Perim_cef, y = after_stat(density)), binwidth = 1, col = 'grey') + geom_density(aes(x = Perim_cef, y = after_stat(density)), col = 'red', kernel = "rectangular", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'epanechnikov'), kernel = "epanechnikov", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'gaussian'), kernel = "gaussian", adjust = 2)
scale_color_manual(values = c(epanechnikov = 'green', gaussian = 'blue'))
ggplot() +
geom_histogram(aes(x = Perim_cef, y = after_stat(density)), binwidth = 1) + geom_density(aes(x = Perim_cef, y = after_stat(density)), col = 'red', kernel = "rectangular", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'epanechnikov'), kernel = "epanechnikov", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'gaussian'), kernel = "gaussian", adjust = 2)
scale_color_manual(values = c(epanechnikov = 'green', gaussian = 'blue'))
ggplot() +
geom_histogram(aes(x = Perim_cef, y = after_stat(density)), binwidth = 1) + geom_density(aes(x = Perim_cef, y = after_stat(density)), col = 'green', kernel = "rectangular", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'epanechnikov'), kernel = "epanechnikov", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'gaussian'), kernel = "gaussian", adjust = 2)
scale_color_manual(values = c(epanechnikov = 'red', gaussian = 'blue'))
ggplot() +
geom_histogram(aes(x = Perim_cef, y = after_stat(density)), binwidth = 1) + geom_density(aes(x = Perim_cef, y = after_stat(density)), col = 'rectangular', kernel = "rectangular", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'epanechnikov'), kernel = "epanechnikov", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'gaussian'), kernel = "gaussian", adjust = 2)
ggplot() +
geom_histogram(aes(x = Perim_cef, y = after_stat(density)), binwidth = 1) + geom_density(aes(x = Perim_cef, y = after_stat(density)), col = 'green', kernel = "rectangular", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'epanechnikov'), kernel = "epanechnikov", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'gaussian'), kernel = "gaussian", adjust = 2)
ggplot() +
geom_histogram(aes(x = Perim_cef, y = after_stat(density)), binwidth = 1) + geom_density(aes(x = Perim_cef, y = after_stat(density)), col = "green", kernel = "rectangular", adjust = 0.5) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'epanechnikov'), kernel = "epanechnikov", adjust = 0.5) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'gaussian'), kernel = "gaussian", adjust = 0.5)
ggplot() +
geom_histogram(aes(x = Perim_cef, y = after_stat(density)), binwidth = 1) + geom_density(aes(x = Perim_cef, y = after_stat(density)), col = 'green', kernel = "rectangular", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'epanechnikov'), kernel = "epanechnikov", adjust = 2) +
geom_density(aes(x = Perim_cef, y = after_stat(density), col = 'gaussian'), kernel = "gaussian", adjust = 2)
data <- read.table("ENNyS_menorA2.txt", header = TRUE)
data <- read.table("ENNyS_menorA2.txt", header = TRUE)
attach(data)
library(ggplot2)
ggplot(data, aes(x = Perim_cef)) +
geom_histogram(aes(y = ..density..), breaks = seq(floor(min(Perim_cef)),ceiling(max(Perim_cef)) + 1, by = 1.75),fill = "lightblue", colour = "black") +
geom_density(kernel = "gaussian", colour = "red", n = 512) +  # Densidad con núcleo gaussiano
geom_density(kernel = "rectangular", colour = "green", n = 512) +
geom_density(kernel = "epanechnikov", colour = "blue", n = 512)+
theme_minimal()
hist_data <- hist(Perim_cef, breaks = seq(floor(min(Perim_cef)),ceiling(max(Perim_cef)) + 1, by = 1.75), plot = FALSE)
bin_widths <- diff(hist_data$breaks)
# Buscamos los indices de los bins que contengan al 42 y al 48.
indices_extremos <- which(hist_data$breaks[-length(hist_data$breaks)] <= 48 & hist_data$breaks[-1] >= 42)
# Calculo el área de los bins que están totalmente en rango (ambos bordes)
bins_totales <- hist_data$density[indices_extremos[-c(1, length(indices_extremos))]]
area_de_totales <- sum(bins_totales * bin_widths[indices_extremos[-c(1, length(indices_extremos))]])
# Área parcial del primer bin en rango
primer_bin_parcial = hist_data$breaks[indices_extremos[1] + 1] - 42
primer_area = primer_bin_parcial * hist_data$density[indices_extremos[1]]
# Área parcial del último bin en rango
ultimo_bin_parcial = 48 - hist_data$breaks[indices_extremos[length(indices_extremos)]]
ultima_area = ultimo_bin_parcial * hist_data$density[indices_extremos[length(indices_extremos)]]
# Sumo las áreas
total_area = area_de_totales + primer_area + ultima_area
#Calculo la probabilidad usando la densidad
density_data <- density(Perim_cef, kernel = "epanechnikov", from=floor(min(Perim_cef)), to=ceiling(max(Perim_cef)), n=512)
x_vals <- seq(42, 48, length.out = 100)
y_vals <- approx(density_data$x, density_data$y, xout=x_vals)$y
prob_density <- sum(y_vals) * (x_vals[2] - x_vals[1])
cat("La probabilidad calculada con el histograma es: ", total_area, "\t")
cat("La probabilidad calculada con la estimacion de la densidad es: ", prob_density)
ggplot(data, aes(x = Perim_cef)) +
geom_density(kernel = "gaussian", bw =gaussian_density$bw ,colour = "red") +
geom_density(kernel = "gaussian",bw =rectangular_density$bw*2,colour = "green") +
geom_density(kernel = "gaussian",bw = epanechnikov_density$bw/2, colour = "blue")+
theme_minimal() + ylab("Densidad") + xlab("Perim_Cef")
gaussian_density <- density(data= data$Perim_cef,kernel = "gaussian")
gaussian_density <- density(data$Perim_cef,kernel = "gaussian")
gaussian_density <- density(data$Perim_cef,kernel = "gaussian")
ggplot(data, aes(x = Perim_cef)) +
geom_density(kernel = "gaussian", bw =gaussian_density$bw ,colour = "red") +
geom_density(kernel = "gaussian",bw =rectangular_density$bw*2,colour = "green") +
geom_density(kernel = "gaussian",bw = epanechnikov_density$bw/2, colour = "blue")+
theme_minimal() + ylab("Densidad") + xlab("Perim_Cef")
gaussian_density <- density(data$Perim_cef,kernel = "gaussian")
rectangular_density <- density(data$Perim_cef,kernel = "rectangular")
epanechnikov_density <- density(data$Perim_cef,kernel = "epanechnikov")
ggplot(data, aes(x = Perim_cef)) +
geom_density(kernel = "gaussian", bw =gaussian_density$bw ,colour = "red") +
geom_density(kernel = "gaussian",bw =rectangular_density$bw*2,colour = "green") +
geom_density(kernel = "gaussian",bw = epanechnikov_density$bw/2, colour = "blue")+
theme_minimal() + ylab("Densidad") + xlab("Perim_Cef")
data <- read.table("ENNyS_menorA2.txt", header = TRUE)
attach(data)
library(ggplot2)
ggplot(data, aes(x = Perim_cef)) +
geom_histogram(aes(y = ..density..), breaks = seq(floor(min(Perim_cef)),ceiling(max(Perim_cef)) + 1, by = 1.75),fill = "lightblue", colour = "black") +
geom_density(kernel = "gaussian", colour = "red", n = 512) +  # Densidad con núcleo gaussiano
geom_density(kernel = "rectangular", colour = "green", n = 512) +
geom_density(kernel = "epanechnikov", colour = "blue", n = 512)+
theme_minimal()
hist_data <- hist(Perim_cef, breaks = seq(floor(min(Perim_cef)),ceiling(max(Perim_cef)) + 1, by = 1.75), plot = FALSE)
bin_widths <- diff(hist_data$breaks)
# Buscamos los indices de los bins que contengan al 42 y al 48.
indices_extremos <- which(hist_data$breaks[-length(hist_data$breaks)] <= 48 & hist_data$breaks[-1] >= 42)
# Calculo el área de los bins que están totalmente en rango (ambos bordes)
bins_totales <- hist_data$density[indices_extremos[-c(1, length(indices_extremos))]]
area_de_totales <- sum(bins_totales * bin_widths[indices_extremos[-c(1, length(indices_extremos))]])
# Área parcial del primer bin en rango
primer_bin_parcial = hist_data$breaks[indices_extremos[1] + 1] - 42
primer_area = primer_bin_parcial * hist_data$density[indices_extremos[1]]
# Área parcial del último bin en rango
ultimo_bin_parcial = 48 - hist_data$breaks[indices_extremos[length(indices_extremos)]]
ultima_area = ultimo_bin_parcial * hist_data$density[indices_extremos[length(indices_extremos)]]
# Sumo las áreas
total_area = area_de_totales + primer_area + ultima_area
#Calculo la probabilidad usando la densidad
density_data <- density(Perim_cef, kernel = "epanechnikov", from=floor(min(Perim_cef)), to=ceiling(max(Perim_cef)), n=512)
x_vals <- seq(42, 48, length.out = 100)
y_vals <- approx(density_data$x, density_data$y, xout=x_vals)$y
prob_density <- sum(y_vals) * (x_vals[2] - x_vals[1])
cat("La probabilidad calculada con el histograma es: ", total_area, "\t")
cat("La probabilidad calculada con la estimacion de la densidad es: ", prob_density)
gaussian_density <- density(data$Perim_cef,kernel = "gaussian")
rectangular_density <- density(data$Perim_cef,kernel = "rectangular")
epanechnikov_density <- density(data$Perim_cef,kernel = "epanechnikov")
ggplot(data, aes(x = Perim_cef)) +
geom_density(kernel = "gaussian", bw =gaussian_density$bw ,colour = "red") +
geom_density(kernel = "gaussian",bw =rectangular_density$bw*2,colour = "green") +
geom_density(kernel = "gaussian",bw = epanechnikov_density$bw/2, colour = "blue")+
theme_minimal() + ylab("Densidad") + xlab("Perim_Cef")
ggplot(data, aes(x = Perim_cef)) +
geom_density(kernel = "rectangular", bw =gaussian_density$bw ,colour = "red") +
geom_density(kernel = "rectangular",bw =rectangular_density$bw*2,colour = "green") +
geom_density(kernel = "rectangular",bw = epanechnikov_density$bw/2, colour = "blue")+
theme_minimal() + ylab("Densidad") + xlab("Perim_Cef")
ggplot(data, aes(x = Perim_cef)) +
geom_density(kernel = "epanechnikov", bw =gaussian_density$bw ,colour = "red") +
geom_density(kernel = "epanechnikov",bw =rectangular_density$bw*2,colour = "green") +
geom_density(kernel = "epanechnikov",bw = epanechnikov_density$bw/2, colour = "blue")+
theme_minimal() + ylab("Densidad") + xlab("Perim_Cef")
# Histograma y densidad estimada con núcleo gaussiano
ggplot(data, aes(x = Perim_cef)) +
geom_histogram(aes(y = ..density..), binwidth = 1,position = 'identity',alpha = 0.5) +
geom_density(alpha = 0.7) +
ggtitle("Histograma y Densidad Gaussiana de Perímetro Cefálico") +
xlab("Perímetro Cefálico") +
ylab("Densidad") +
theme_minimal()
# Histograma y densidad estimada con núcleo gaussiano
ggplot(data, aes(x = Perim_cef,fill = Sexo)) +
geom_histogram(aes(y = ..density..), binwidth = 1,position = 'identity',alpha = 0.5) +
geom_density(alpha = 0.7) +
ggtitle("Histograma y Densidad Gaussiana de Perímetro Cefálico Por Sexo") +
xlab("Perímetro Cefálico") +
ylab("Densidad") +
theme_minimal()+
scale_fill_brewer(palette = "Set1")
ggplot(data, aes(x = Perim_cef)) +
geom_histogram(aes(y = ..density..), position = "identity", alpha = 0.5) +
geom_density(alpha = 0.7) +
ggtitle("Densidades Gaussianas de Perímetro Cefálico") +
xlab("Perímetro Cefálico") +
ylab("Densidad")
# Suponiendo que los tipos de embarazo son 'Simple' y 'Múltiple'
ggplot(data, aes(x = Perim_cef, fill = Tipo_embarazo)) +
geom_histogram(aes(y = ..density..), position = "identity", alpha = 0.5) +
geom_density(alpha = 0.7) +
ggtitle("Densidades Gaussianas de Perímetro Cefálico por Tipo de Embarazo") +
xlab("Perímetro Cefálico") +
ylab("Densidad") +
scale_fill_brewer(palette = "Set1")
print("proporcion embarazos")
prop.table(table(data$Tipo_embarazo))
library(aplpack)
bagplot(Perim_cef, Talla, approx.limit = length(Perim_cef), xlab = "Perímetro Cefálico", ylab = "Talla",
main = "Bagplot de Perímetro Cefálico vs. Talla")
quartil_0.1 <- quantile(Talla,0.1)
quartil_0.25 <- quantile(Talla, 0.25)
quartil_0.75 <- quantile(Talla, 0.75)
quartil_0.9 <- quantile(Talla, 0.9)
cat("el cuartil 0.1 es:", quartil_0.1, "\n")
cat("el cuartil 0.25 es:", quartil_0.25, "\n")
cat("el cuartil 0.75 es:", quartil_0.75, "\n")
cat("el cuartil 0.9 es:", quartil_0.9, "\n")
bgplot_ <- compute.bagplot(Perim_cef, Talla, approx.limit = length(Perim_cef))
values_bag <- bgplot_$pxy.bag
values_fence <- bgplot_$pxy.outer
no_outliers <- rbind(values_bag, values_fence)
bagplot(no_outliers, approx.limit = (length(no_outliers)/2), xlab = "Perímetro Cefálico", ylab = "Talla",
main = "Bagplot de Perímetro Cefálico vs. Talla (Sin los outliers del primer Bagplot")
bgp_grafico <- bagplot(Perim_cef, Talla, approx.limit = length(Perim_cef), xlab = "Perímetro Cefálico", ylab = "Talla",
main = "Bagplot de Perímetro Cefálico vs. Talla")
data_varones <- subset(data, Sexo == "Varon")
bagplot(data_varones$Perim_cef, data_varones$Talla, approx.limit = length(data_varones$Perim_cef), xlab = "Perímetro Cefálico", ylab = "Talla",
main = "Bagplot de Perímetro Cefálico vs. Talla (Hombres)")
bp_hombres <- compute.bagplot(data_varones$Perim_cef, data_varones$Talla, approx.limit = length(data_varones$Perim_cef))
values_hombres <- bp_hombres$hull.bag
values_h_outliers <- bp_hombres$pxy.outlier
data_mujeres <- subset(data, Sexo == "Mujer")
bagplot(data_mujeres$Perim_cef, data_mujeres$Talla, approx.limit = length(data_mujeres$Perim_cef), xlab = "Perímetro Cefálico", ylab = "Talla",
main = "Bagplot de Perímetro Cefálico vs. Talla (Mujeres)")
bp_mujeres <- compute.bagplot(data_mujeres$Perim_cef, data_mujeres$Talla, approx.limit = length(data_mujeres$Perim_cef))
values_mujeres <- bp_mujeres$hull.bag
values_m_outliers <- bp_mujeres$pxy.outlier
cat("el minimo valor de perimetro cefalico de mujeres dentro de la bolsa es:", min(values_mujeres[,1]), "\n")
cat("el minimo valor de perimetro cefalico de hombres dentro de la bolsa es:", min(values_hombres[,1]), "\n")
cat("el maximo valor de perimetro cefalico de mujeres dentro de la bolsa es:", max(values_mujeres[,1]), "\n")
cat("el maximo valor de perimetro cefalico de hombres dentro de la bolsa es:", max(values_hombres[,1]), "\n")
cat("el minimo valor de talla de mujeres dentro de la bolsa es:", min(values_mujeres[,2]), "\n")
cat("el minimo valor de talla de hombres dentro de la bolsa es:", min(values_hombres[,2]), "\n")
cat("el maximo valor de talla de mujeres dentro de la bolsa es:", max(values_mujeres[,2]), "\n")
cat("el maximo valor de talla de hombres dentro de la bolsa es:", max(values_hombres[,2]), "\n")
values_outliers <- bgplot_$pxy.outlier
values_hm_outliers <- rbind(values_h_outliers, values_m_outliers)
outliers <- rbind(values_outliers, values_hm_outliers)
filas_duplicadas <- duplicated(outliers) | duplicated(outliers, fromLast = TRUE)
diferencia <- outliers[!filas_duplicadas, ]
plot(diferencia)
source("C:/Users/lucaz/Downloads/Groisman_Gutter_Oyhanart.Rmd")
source("C:/Users/lucaz/Downloads/Groisman_Gutter_Oyhanart.Rmd")
source("C:/Users/lucaz/Downloads/Groisman_Gutter_Oyhanart.Rmd")
source("C:/Users/lucaz/Downloads/Groisman_Gutter_Oyhanart.Rmd")
source("C:/Users/lucaz/Downloads/Groisman_Gutter_Oyhanart.Rmd")
source("C:/Users/lucaz/Downloads/Groisman_Gutter_Oyhanart.Rmd")
source("C:/Users/lucaz/Downloads/Groisman_Gutter_Oyhanart.Rmd")
source("C:/Users/lucaz/Downloads/Groisman_Gutter_Oyhanart.Rmd")
source("C:/Users/lucaz/Downloads/Groisman_Gutter_Oyhanart.Rmd")
source("C:/Users/lucaz/Downloads/Groisman_Gutter_Oyhanart.Rmd")
# Ejercicio 1
source("C:/Users/lucaz/Downloads/Groisman_Gutter_Oyhanart.Rmd")
data <- read.table("ENNyS_menorA2.txt", header = TRUE)
attach(data)
library(ggplot2)
ggplot(data, aes(x = Perim_cef)) +
geom_histogram(aes(y = ..density..), breaks = seq(floor(min(Perim_cef)),ceiling(max(Perim_cef)) + 1, by = 1.75),fill = "lightblue", colour = "black") +
geom_density(kernel = "gaussian", colour = "red", n = 512) +  # Densidad con núcleo gaussiano
geom_density(kernel = "rectangular", colour = "green", n = 512) +
geom_density(kernel = "epanechnikov", colour = "blue", n = 512)+
theme_minimal()
hist_data <- hist(Perim_cef, breaks = seq(floor(min(Perim_cef)),ceiling(max(Perim_cef)) + 1, by = 1.75), plot = FALSE)
bin_widths <- diff(hist_data$breaks)
# Buscamos los indices de los bins que contengan al 42 y al 48.
indices_extremos <- which(hist_data$breaks[-length(hist_data$breaks)] <= 48 & hist_data$breaks[-1] >= 42)
# Calculo el área de los bins que están totalmente en rango (ambos bordes)
bins_totales <- hist_data$density[indices_extremos[-c(1, length(indices_extremos))]]
area_de_totales <- sum(bins_totales * bin_widths[indices_extremos[-c(1, length(indices_extremos))]])
# Área parcial del primer bin en rango
primer_bin_parcial = hist_data$breaks[indices_extremos[1] + 1] - 42
primer_area = primer_bin_parcial * hist_data$density[indices_extremos[1]]
# Área parcial del último bin en rango
ultimo_bin_parcial = 48 - hist_data$breaks[indices_extremos[length(indices_extremos)]]
ultima_area = ultimo_bin_parcial * hist_data$density[indices_extremos[length(indices_extremos)]]
# Sumo las áreas
total_area = area_de_totales + primer_area + ultima_area
#Calculo la probabilidad usando la densidad
density_data <- density(Perim_cef, kernel = "epanechnikov", from=floor(min(Perim_cef)), to=ceiling(max(Perim_cef)), n=512)
x_vals <- seq(42, 48, length.out = 100)
y_vals <- approx(density_data$x, density_data$y, xout=x_vals)$y
prob_density <- sum(y_vals) * (x_vals[2] - x_vals[1])
cat("La probabilidad calculada con el histograma es: ", total_area, "\t")
cat("La probabilidad calculada con la estimacion de la densidad es: ", prob_density)
gaussian_density <- density(data$Perim_cef,kernel = "gaussian")
rectangular_density <- density(data$Perim_cef,kernel = "rectangular")
epanechnikov_density <- density(data$Perim_cef,kernel = "epanechnikov")
ggplot(data, aes(x = Perim_cef)) +
geom_density(kernel = "gaussian", bw =gaussian_density$bw ,colour = "red") +
geom_density(kernel = "gaussian",bw =rectangular_density$bw*2,colour = "green") +
geom_density(kernel = "gaussian",bw = epanechnikov_density$bw/2, colour = "blue")+
theme_minimal() + ylab("Densidad") + xlab("Perim_Cef")
ggplot(data, aes(x = Perim_cef)) +
geom_density(kernel = "rectangular", bw =gaussian_density$bw ,colour = "red") +
geom_density(kernel = "rectangular",bw =rectangular_density$bw*2,colour = "green") +
geom_density(kernel = "rectangular",bw = epanechnikov_density$bw/2, colour = "blue")+
theme_minimal() + ylab("Densidad") + xlab("Perim_Cef")
ggplot(data, aes(x = Perim_cef)) +
geom_density(kernel = "epanechnikov", bw =gaussian_density$bw ,colour = "red") +
geom_density(kernel = "epanechnikov",bw =rectangular_density$bw*2,colour = "green") +
geom_density(kernel = "epanechnikov",bw = epanechnikov_density$bw/2, colour = "blue")+
theme_minimal() + ylab("Densidad") + xlab("Perim_Cef")
# Histograma y densidad estimada con núcleo gaussiano
ggplot(data, aes(x = Perim_cef)) +
geom_histogram(aes(y = ..density..), binwidth = 1,position = 'identity',alpha = 0.5) +
geom_density(alpha = 0.7) +
ggtitle("Histograma y Densidad Gaussiana de Perímetro Cefálico") +
xlab("Perímetro Cefálico") +
ylab("Densidad") +
theme_minimal()
# Histograma y densidad estimada con núcleo gaussiano
ggplot(data, aes(x = Perim_cef,fill = Sexo)) +
geom_histogram(aes(y = ..density..), binwidth = 1,position = 'identity',alpha = 0.5) +
geom_density(alpha = 0.7) +
ggtitle("Histograma y Densidad Gaussiana de Perímetro Cefálico Por Sexo") +
xlab("Perímetro Cefálico") +
ylab("Densidad") +
theme_minimal()+
scale_fill_brewer(palette = "Set1")
ggplot(data, aes(x = Perim_cef)) +
geom_histogram(aes(y = ..density..), position = "identity", alpha = 0.5) +
geom_density(alpha = 0.7) +
ggtitle("Densidades Gaussianas de Perímetro Cefálico") +
xlab("Perímetro Cefálico") +
ylab("Densidad")
# Suponiendo que los tipos de embarazo son 'Simple' y 'Múltiple'
ggplot(data, aes(x = Perim_cef, fill = Tipo_embarazo)) +
geom_histogram(aes(y = ..density..), position = "identity", alpha = 0.5) +
geom_density(alpha = 0.7) +
ggtitle("Densidades Gaussianas de Perímetro Cefálico por Tipo de Embarazo") +
xlab("Perímetro Cefálico") +
ylab("Densidad") +
scale_fill_brewer(palette = "Set1")
print("proporcion embarazos")
prop.table(table(data$Tipo_embarazo))
library(aplpack)
bagplot(Perim_cef, Talla, approx.limit = length(Perim_cef), xlab = "Perímetro Cefálico", ylab = "Talla",
main = "Bagplot de Perímetro Cefálico vs. Talla")
quartil_0.1 <- quantile(Talla,0.1)
quartil_0.25 <- quantile(Talla, 0.25)
quartil_0.75 <- quantile(Talla, 0.75)
quartil_0.9 <- quantile(Talla, 0.9)
cat("el cuartil 0.1 es:", quartil_0.1, "\n")
cat("el cuartil 0.25 es:", quartil_0.25, "\n")
cat("el cuartil 0.75 es:", quartil_0.75, "\n")
cat("el cuartil 0.9 es:", quartil_0.9, "\n")
bgplot_ <- compute.bagplot(Perim_cef, Talla, approx.limit = length(Perim_cef))
values_bag <- bgplot_$pxy.bag
values_fence <- bgplot_$pxy.outer
no_outliers <- rbind(values_bag, values_fence)
bagplot(no_outliers, approx.limit = (length(no_outliers)/2), xlab = "Perímetro Cefálico", ylab = "Talla",
main = "Bagplot de Perímetro Cefálico vs. Talla (Sin los outliers del primer Bagplot")
bgp_grafico <- bagplot(Perim_cef, Talla, approx.limit = length(Perim_cef), xlab = "Perímetro Cefálico", ylab = "Talla",
main = "Bagplot de Perímetro Cefálico vs. Talla")
data_varones <- subset(data, Sexo == "Varon")
bagplot(data_varones$Perim_cef, data_varones$Talla, approx.limit = length(data_varones$Perim_cef), xlab = "Perímetro Cefálico", ylab = "Talla",
main = "Bagplot de Perímetro Cefálico vs. Talla (Hombres)")
bp_hombres <- compute.bagplot(data_varones$Perim_cef, data_varones$Talla, approx.limit = length(data_varones$Perim_cef))
values_hombres <- bp_hombres$hull.bag
values_h_outliers <- bp_hombres$pxy.outlier
data_mujeres <- subset(data, Sexo == "Mujer")
bagplot(data_mujeres$Perim_cef, data_mujeres$Talla, approx.limit = length(data_mujeres$Perim_cef), xlab = "Perímetro Cefálico", ylab = "Talla",
main = "Bagplot de Perímetro Cefálico vs. Talla (Mujeres)")
bp_mujeres <- compute.bagplot(data_mujeres$Perim_cef, data_mujeres$Talla, approx.limit = length(data_mujeres$Perim_cef))
values_mujeres <- bp_mujeres$hull.bag
values_m_outliers <- bp_mujeres$pxy.outlier
cat("el minimo valor de perimetro cefalico de mujeres dentro de la bolsa es:", min(values_mujeres[,1]), "\n")
cat("el minimo valor de perimetro cefalico de hombres dentro de la bolsa es:", min(values_hombres[,1]), "\n")
cat("el maximo valor de perimetro cefalico de mujeres dentro de la bolsa es:", max(values_mujeres[,1]), "\n")
cat("el maximo valor de perimetro cefalico de hombres dentro de la bolsa es:", max(values_hombres[,1]), "\n")
cat("el minimo valor de talla de mujeres dentro de la bolsa es:", min(values_mujeres[,2]), "\n")
cat("el minimo valor de talla de hombres dentro de la bolsa es:", min(values_hombres[,2]), "\n")
cat("el maximo valor de talla de mujeres dentro de la bolsa es:", max(values_mujeres[,2]), "\n")
cat("el maximo valor de talla de hombres dentro de la bolsa es:", max(values_hombres[,2]), "\n")
values_outliers <- bgplot_$pxy.outlier
values_hm_outliers <- rbind(values_h_outliers, values_m_outliers)
outliers <- rbind(values_outliers, values_hm_outliers)
filas_duplicadas <- duplicated(outliers) | duplicated(outliers, fromLast = TRUE)
diferencia <- outliers[!filas_duplicadas, ]
plot(diferencia)
source("C:/Users/lucaz/Downloads/Groisman_Gutter_Oyhanart.Rmd")
qnorm(0)
qnorm(0.1)
qnorm(1/2)
qnorm(1/2+.01)
qnorm(1/2)
qnorm(.025)
qnorm(1-.025)
theta_mv <- sqrt(sum(datos^2))
knitr::opts_chunk$set(echo = TRUE)
```{}
# Seteo la semilla
set.seed(42)
# Genero la muestra
sample <- rexp(20, rate = 1/2)
# Print the generated sample
print(sample)
# Genero la muestra
?sample <- rexp(20, rate = 1/2)
# Genero la muestra
sample <- rexp(20, rate = 1/2)
# Print the generated sample
print(sample)
?rexp
?rexp
?rexp()
rexp
rexp
rexp
return(media^2)
media <- mean(data)
T1 <- function(data){
media <- mean(data)
return(media^2)
}
print(T1(sample))
print(T1(sample))
# Defino los estimadores
T1 <- mean(data)^2
# Defino los estimadores
T1 <- mean(sample)^2
# Genero la muestra
sample <- rexp(20, rate = 1/2)
# Seteo la semilla
set.seed(42)
# Genero la muestra
sample <- rexp(20, rate = 1/2)
# Defino los estimadores
T1 <- mean(sample)^2
print(T1)
T2 <- sum(sample^2)/2*length(sample)
T2 <- sum(sample^2)/(2*length(sample))
print(T1)
print(T2)
# Genero la muestra
n <- 20
lambda <- 1/2
sample <- rexp(n, rate = lambda)
T2 <- sum(sample^2)/(2*n)
print(T1)
print(T2)
T2 <- sum(sample^2)/(2*n)
print(T2)
T2 <- sum(sample^2)/(2*20)
print(T2)
T2 <- sum(sample^2)/(2*length(sample))
print(T2)
T2 <- sum(sample^2)/(2*n)
# Seteo la semilla
set.seed(42)
# Genero la muestra
n <- 20
lambda <- 1/2
sample <- rexp(n, rate = lambda)
# Defino los estimadores
T1 <- mean(sample)^2
T2 <- sum(sample^2)/(2*n)
print(T1)
print(T2)
source("~/.active-rstudio-document", echo=TRUE)
# Seteo la semilla
set.seed(2023)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
print(mean(res_T1))
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
res_T1
boxplot(res_T1, res_T2, xlab= 'Estimadores', ylab='N_reps')
boxplot(res_T1, res_T2, main='Boxplot paralelos', col =c('green', 'orange') xlab= 'Estimadores', ylab='N_reps')
boxplot(res_T1, res_T2, main='Boxplot paralelos', col=c('green', 'orange'), xlab= 'Estimadores', ylab='N_reps')
boxplot(res_T1, res_T2, main='Boxplot paralelos', col=c('green', 'orange'), xlab= 'Estimadores', ylab='N_reps')
boxplot(res_T1, res_T2, main='Boxplot paralelos', col=c('green', 'orange'), xlab= 'Estimadores', ylab='Valores obtenidos')
boxplot(res_T1, res_T2, main='Boxplot paralelos', col=c('green', 'orange'), xlab= 'Estimadores', ylab='Valores obtenidos', boxwex=1)
boxplot(res_T1, res_T2, main='Boxplot paralelos', col=c('green', 'orange'), xlab= 'Estimadores', ylab='Valores obtenidos', boxwex=0.5)
boxplot(res_T1, res_T2, main='Boxplot paralelos', col=c('green', 'orange'), xlab= 'Estimadores', ylab='Valores obtenidos', boxwex=0.25)
boxplot(res_T1, res_T2, main='Boxplot paralelos', col=c('green', 'orange'), xlab= 'Estimadores', ylab='Valores obtenidos', boxwex=0.25, names=c('T1', 'T2'))
boxplot(res_T1, res_T2, main='Boxplot paralelos para T1 y T2', col=c('green', 'orange'), xlab= 'Estimadores', ylab='Valores obtenidos', boxwex=0.25, names=c('T1', 'T2'))
N_rep <- 2000
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
# d)
densidad_T1 <- density(res_T1, kernel = 'gaussian')
# d)
densidad_T1 <- density(res_T1, kernel = 'gaussian')
plot(densidad_T1)
densidad_T2 <- density(res_T2, kernel = 'gaussian')
plot(densidad_T1, densidad_T2)
plot(c(densidad_T1, densidad_T2))
plot(densidad_T1)
plot(densidad_T2)
curve(densidad_T2, add=TRUE)
densidad_T2 <- density(res_T2, kernel = 'gaussian')
curve(densidad_T2, add=TRUE)
plot(densidad_T1)
curve(densidad_T2, add=TRUE)
densidad_T2(-0.531)
densidad_T2[-0.531]
print(densidad_T2[-0.531])
curve(densidad_T2$x, densidad_T2$y, add=TRUE)
lines(densidad_T2)
source("~/.active-rstudio-document", echo=TRUE)
plot(densidad_T1, col='blue', main= 'Densidades estimadas para T1 y T2')
lines(densidad_T2, col="red")
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
qchisq(0.95, 1)
ln(6/5.5)
log(6/5.5)
-2*(40*5.5*(log(6/5.5)+1)-240)
knitr::opts_chunk$set(echo = TRUE)
setwd("C:/Users/lucaz/OneDrive/Documents/Exactas/Estadistica/tp_final")
=======
col = c("red", "black",'green'), lty = c(1, 2), lwd = 2)
linearSmooth <- function(X, Y, h){
#núcleo normal
K <- function(u) dnorm(u)
n<- length(X)
col_ones <- rep(1, n)
values <- rep(0, n)
for (i in 1:n) {
#matriz X de la regresión lineal
X_matrix <- cbind(col_ones, X-X[i])
weights <- K((X-X[i]) / h)
W <- diag(weights)
XtWX.inv <- solve(t(X_matrix)%*%W%*%X_matrix)
a0_hat <- (XtWX.inv%*%t(X_matrix)%*%W%*%Y)[1]
values[i] <- a0_hat #resultados de a0 en cada valor de X
}
return(values)
}
est_lin_loc <- linearSmooth(females$HIP.CIRCUMFERENCE, females$BUTTOCK.KNEE.LENGTH, 40)
plot(females$HIP.CIRCUMFERENCE, est_lin_loc)
plot(NULL, xlim = range(females$HIP.CIRCUMFERENCE), ylim = range(c(fit_nw_optimal, est_lin_loc)),
main = "Estimadores Nadaraya-Watson y Lineal Local",
xlab = "Circunferencia de cadera (mm)",
ylab = "Longitud de fémur (mm)")
# Agregar los estimadores al gráfico
lines(sort(females$HIP.CIRCUMFERENCE), fit_nw_optimal[order(females$HIP.CIRCUMFERENCE)], col = "red", lwd = 3)
lines(sort(females$HIP.CIRCUMFERENCE), est_lin_loc[order(females$HIP.CIRCUMFERENCE)], col = "green", lwd = 3)
legend("topleft", legend = c("Nadaraya-Watson", "Estimador Lineal Local"),
col = c("red", "green"), lty = 1, lwd = 2)
dnorm(HIP.CIRCUMFERENCE)
dnorm((HIP.CIRCUMFERENCE- HIP.CIRCUMFERENCE[1])/15)
(HIP.CIRCUMFERENCE- HIP.CIRCUMFERENCE[1])
# Defino el estimador de NW para un x0
nwsmooth <- function(x0, x, y, bandwidth){
# Armo el vector al que le aplico el núcleo normal
vect <- (x - x0)/bandwidth
# Calculo los pesos
weights <- dnorm(vect)
return(sum(weights*y)/sum(weights))
}
nwsmooth(x, x, y, 15)
sapply(x, nwsmooth, x, y, 15)
# Defino el estimador de NW para un x0
nwsmooth <- function(x0, x, y, bandwidth){
# Armo el vector al que le aplico el núcleo normal
vect <- (x - x0)/bandwidth
# Calculo los pesos
weights <- dnorm(vect)
return(sum(weights*y)/sum(weights))
}
# Calculo el leave-one-out CV
cv_nwsmooth <- function(bandwidth, x, y){
# Vector m, con nwsmooth aplicado a x_i en la posición i
m <- sapply(x, nwsmooth, x, y, bandwidth)
# Armo el vector w, que tiene el coeficiente w_i,h en la posición i
arg_matrix <- outer(x, x, "-") * (1/bandwidth)  # Matriz con (x[i]-x[j])/bandwidth en la posición ij
kernel_matrix <- apply(arg_matrix, c(1, 2), dnorm)  # Núcleo normal aplicado a cada posición
column_sums <- colSums(kernel_matrix)  # Sumo las columnas de kernel_matrix, me queda el denominador de w_i,h
gaussian_kernel_0 <- dnorm(0)  # El num de w_i,h para todo i
w <- gaussian_kernel_0 / column_sums  # Consigo w
# vector con error de predicción de m_h^-i en la posición i
errors <- ((y-m)/(1-w))^2
return(mean(errors))
}
# Defino grilla de bandwidths y calculo el error de cv para cada valor de h en la grilla
bandwidths <- 4:24
errors <- sapply(bandwidths, cv_nwsmooth, x = HIP.CIRCUMFERENCE, y = BUTTOCK.KNEE.LENGTH)
# Encuentro el valor mínimo de error y su índice correspondiente
min_error <- min(errors)
min_error_index <- which.min(errors)
best_bandwidth <- bandwidths[min_error_index]
# Calculo la regresión
ordenado <- order(HIP.CIRCUMFERENCE)
y <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, best_bandwidth)
# Grafico
plot(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
pch = 19, col = "light blue")
lines(HIP.CIRCUMFERENCE[ordenado], y, col = "red")
# Ploteo la función objectivo marcando el valor mínimo
plot(bandwidths, errors, type = "b", main = "Leave one out CV Error para nwsmooth vs Bandwidth",
xlab = "Bandwidth", ylab = "CV Error", col = "blue", pch = 19)
# Marca el valor mínimo de error en el plot
points(best_bandwidth, min_error, col = "red", pch = 19, cex = 1.5)
text(best_bandwidth, min_error, labels = paste("Min Error:", round(min_error, 2)), pos = 3, col = "red")
# Calculo la regresión
ordenado <- order(HIP.CIRCUMFERENCE)
y <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, best_bandwidth)
# Grafico
plot(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
pch = 19, col = "light blue")
lines(HIP.CIRCUMFERENCE[ordenado], y, col = "red")
# Ploteo la función objectivo marcando el valor mínimo
plot(bandwidths, errors, type = "b", main = "Leave one out CV Error para nwsmooth vs Bandwidth",
xlab = "Bandwidth", ylab = "CV Error", col = "blue", pch = 19)
# Marca el valor mínimo de error en el plot
points(best_bandwidth, min_error, col = "red", pch = 19, cex = 1.5)
text(best_bandwidth, min_error, labels = paste("Min Error:", round(min_error, 2)), pos = 3, col = "red")
# Calculo la regresión
ordenado <- order(HIP.CIRCUMFERENCE)
y <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, best_bandwidth)
# Grafico
plot(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
pch = 19, col = "light blue")
lines(HIP.CIRCUMFERENCE[ordenado], y, col = "red")
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
# Calculo la regresión
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, best_bandwidth)
# Grafico
plot(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
pch = 19, col = "light blue")
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red")
# Calculo el error de cv para cada valor de h en la grilla
errors <- sapply(bandwidths, cv_leave_one_out, x = HIP.CIRCUMFERENCE, y = BUTTOCK.KNEE.LENGTH)
# Encuentro el valor mínimo de error y su índice correspondiente
min_error <- min(errors)
min_error_index <- which.min(errors)
best_bandwidth <- bandwidths[min_error_index]
# Ploteo la función objectivo marcando el valor mínimo
plot(bandwidths, errors, type = "b", main = "Leave one out CV Error para ksmooth vs Bandwidth",
xlab = "Bandwidth", ylab = "CV Error", col = "blue", pch = 19)
# Marca el valor mínimo de error en el plot
points(best_bandwidth, min_error, col = "red", pch = 19, cex = 1.5)
text(best_bandwidth, min_error, labels = paste("Min Error:", round(min_error, 2)), pos = 3, col = "red")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(BUTTOCK.KNEE.LENGTH, HIP.CIRCUMFERENCE, "normal", bandwidth = ksmooth_best_bandwidth)
knitr::opts_chunk$set(echo = TRUE)
set.seed(1234)
library(ggplot2)
individuals <- read.table("individuals.csv", header = TRUE, sep = ";")
datos_femenino <- subset(individuals, SEX == 2 & HIP.CIRCUMFERENCE != 0 & BUTTOCK.KNEE.LENGTH!=0)
attach(datos_femenino)
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
pch = 19, col = "blue")
# Division de grupos etarios por cuartiles
cuartiles <- quantile(datos_femenino$AGE.IN.MONTHS,probs = c(0,0.25, 0.5, 0.75,1))
datos_femenino$AGE.GROUP <- cut(datos_femenino$AGE.IN.MONTHS,cuartiles,include.lowest = TRUE, labels = c("0-81","82-128","129-168","169, +"))
#Estimacion de medianas
medianas_estimadas <- tapply(datos_femenino$HIP.CIRCUMFERENCE,datos_femenino$AGE.GROUP,median)
# Función para estimación del se de las medianas
estimar_se_mediana <- function (x, B = 1000){
titahatboot <- rep(0,B)
for(i in 1:B){
Xboot <- sample(x,length(x),replace = TRUE)
titahatboot[i] <- median(Xboot)
}
return(sqrt(mean((titahatboot - mean(titahatboot))^2)))
}
# Cálculo de intervalo bootstrap nivel 0.95
intervalos_confianza <- tapply(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$AGE.GROUP, function(x){
se_boot <- estimar_se_mediana(x)
intervalo_boot <- c(median(x) - 1.96*se_boot,median(x) + 1.96*se_boot)
return(intervalo_boot)
})
# Gráfico
# Los siguientes data frames son unicamente creados para generar el plot
df_medianas <- data.frame(
AGE.GROUP = names(medianas_estimadas),
MEDIAN = medianas_estimadas
)
df_intervalos <- data.frame(
AGE.GROUP = names(intervalos_confianza),
INTERVAL = intervalos_confianza
)
df_intervalos$LOWER <- sapply(df_intervalos$INTERVAL, function(x) x[1])
df_intervalos$UPPER <- sapply(df_intervalos$INTERVAL, function(x) x[2])
df_plot <- merge(datos_femenino,merge(df_medianas,df_intervalos,by="AGE.GROUP"),
by="AGE.GROUP")
ggplot(df_plot, aes(x = AGE.GROUP, y = MEDIAN)) +
geom_point(size = 2) +
geom_errorbar(aes(ymin = LOWER, ymax = UPPER), width = 0.2, linewidth = 1) +
scale_y_continuous(limits = c(min(df_plot$LOWER) * 0.95, max(df_plot$UPPER)),
breaks = seq(from = 600, to = 1000, by = 50)) +
labs(title = "Intervalos de Confianza de medianas de HIP.CIRCUMFERENCE\npor grupo etario",
x = "Grupo Etario", y = "HIP.CIRCUMFERENCE") +
theme_minimal() + theme(
plot.title = element_text(hjust = 0.5, face = "bold", size = 14,
margin = margin(10, 0, 10, 0)),
axis.title = element_text(size = 14))
regresion_100 <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = 100)
regresion_50 <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = 50)
plot(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
pch = 19, col = "light blue")
lines(regresion_100, col = "red")
lines(regresion_50, col = "purple")
legend("bottomright", legend = c("Ventana 100", "Ventana 50"), col = c("red", "purple"), lty = 1, cex = 0.8)
# Defino la grilla de bandwidths
bandwidths <- 20:50
# Defino la función de Leave-One-Out-CV
cv_leave_one_out <- function(x, y, bandwidth) {
n <- length(x)
errors <- numeric(n)
for (i in 1:n) {
# Ajusto el modelo
y_hat <- ksmooth(x[-i], y[-i], "normal", bandwidth = bandwidth, x.points = x[i])$y
# Calculo el mse y lo agrego a errors
mse <- (y[i] - y_hat)^2
errors[i] <- mse
}
return(mean(errors))
}
# Calculo el error de cv para cada valor de h en la grilla
errors <- sapply(bandwidths, cv_leave_one_out, x = HIP.CIRCUMFERENCE, y = BUTTOCK.KNEE.LENGTH)
# Encuentro el valor mínimo de error y su índice correspondiente
min_error <- min(errors)
min_error_index <- which.min(errors)
ksmooth_best_bandwidth <- bandwidths[min_error_index]
# Ploteo la función objectivo marcando el valor mínimo
plot(bandwidths, errors, type = "b", main = "Leave one out CV Error para ksmooth vs Bandwidth",
xlab = "Bandwidth", ylab = "CV Error", col = "blue", pch = 19)
# Marca el valor mínimo de error en el plot
points(ksmooth_best_bandwidth, min_error, col = "red", pch = 19, cex = 1.5)
text(ksmooth_best_bandwidth, min_error, labels = paste("Min Error:", round(min_error, 2)), pos = 3, col = "red")
# Defino el estimador de NW para un x0
nwsmooth <- function(x0, x, y, bandwidth){
# Armo el vector al que le aplico el núcleo normal
vect <- (x - x0)/bandwidth
# Calculo los pesos
weights <- dnorm(vect)
return(sum(weights*y)/sum(weights))
}
# Calculo el leave-one-out CV
cv_nwsmooth <- function(bandwidth, x, y){
# Vector m, con nwsmooth aplicado a x_i en la posición i
m <- sapply(x, nwsmooth, x, y, bandwidth)
# Armo el vector w, que tiene el coeficiente w_i,h en la posición i
arg_matrix <- outer(x, x, "-") * (1/bandwidth)  # Matriz con (x[i]-x[j])/bandwidth en la posición ij
kernel_matrix <- apply(arg_matrix, c(1, 2), dnorm)  # Núcleo normal aplicado a cada posición
column_sums <- colSums(kernel_matrix)  # Sumo las columnas de kernel_matrix, me queda el denominador de w_i,h
gaussian_kernel_0 <- dnorm(0)  # El num de w_i,h para todo i
w <- gaussian_kernel_0 / column_sums  # Consigo w
# Vector con error de predicción de m_h^-i en la posición i
errors <- ((y-m)/(1-w))^2
return(mean(errors))
}
# Defino grilla de bandwidths y calculo el error de cv para cada valor de h en la grilla
bandwidths <- 4:24
errors <- sapply(bandwidths, cv_nwsmooth, x = HIP.CIRCUMFERENCE, y = BUTTOCK.KNEE.LENGTH)
# Encuentro el valor mínimo de error y su índice correspondiente
min_error <- min(errors)
min_error_index <- which.min(errors)
nwsmooth_best_bandwidth <- bandwidths[min_error_index]
# Ploteo la función objectivo marcando el valor mínimo
plot(bandwidths, errors, type = "b", main = "Leave one out CV Error para nwsmooth vs Bandwidth",
xlab = "Bandwidth", ylab = "CV Error", col = "blue", pch = 19)
# Marca el valor mínimo de error en el plot
points(nwsmooth_best_bandwidth, min_error, col = "red", pch = 19, cex = 1.5)
text(nwmooth_best_bandwidth, min_error, labels = paste("Min Error:", round(min_error, 2)), pos = 3, col = "red")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(BUTTOCK.KNEE.LENGTH, HIP.CIRCUMFERENCE, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "purple")
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red")
lines(recta_cuad_min, col = "brown")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(BUTTOCK.KNEE.LENGTH, HIP.CIRCUMFERENCE, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "purple")
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red")
lines(recta_cuad_min$fitted.values, col = "brown")
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("purple", "red", "brown"), lty = 1, cex = 0.8)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(BUTTOCK.KNEE.LENGTH, HIP.CIRCUMFERENCE, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "purple")
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red")
abline(recta_cuad_min$fitted.values, col = "brown")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(BUTTOCK.KNEE.LENGTH, HIP.CIRCUMFERENCE, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(HIP.CIRCUMFERENCE, ksmoothfit, col = "purple")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(HIP.CIRCUMFERENCE, ksmoothfit, col = "purple")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "purple")
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red")
abline(recta_cuad_min$fitted.values, col = "brown")
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "blue", lwd = 10)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 10)
abline(recta_cuad_min$fitted.values, col = "brown", lwd = 10)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "blue", lwd = 10)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 10)
abline(recta_cuad_min, col = "brown", lwd = 10)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = 1, cex = 0.8)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "blue", lwd = 4)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 4)
abline(recta_cuad_min, col = "brown", lwd = 4)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = 1, cex = 0.8)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
lines(ksmoothfit, col = "blue", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
abline(recta_cuad_min, col = "brown", lwd = 3)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = 1, cex = 0.8)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 3, lty = 2)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = 1, cex = 0.8)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 3, lty = 2)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = c(2,1,1), cex = 0.8)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 3, lty = 2)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = c(2,1,1), cex = 0.8, lwd = 3)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 2, lty = 2)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = c(2,1,1), cex = 0.8, lwd = 3)
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 2, lty = 2)
legend("bottomright", legend = c("ksmooth", "nwsmooth", "lm"), col = c("blue", "red", "brown"), lty = c(2,1,1), cex = 0.8, lwd = c(2,3,3))
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 3)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 2, lty = 2)
legend("bottomright", legend = c("ksmooth(41)", "nwsmooth(15)", "lm"), col = c("blue", "red", "brown"), lty = c(2,1,1), cex = 0.8, lwd = c(2,3,3))
# Ajusto los modelos
recta_cuad_min <- lm(BUTTOCK.KNEE.LENGTH ~ HIP.CIRCUMFERENCE)
ksmoothfit <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = ksmooth_best_bandwidth)
ordenado <- order(HIP.CIRCUMFERENCE)
nwfit <- sapply(HIP.CIRCUMFERENCE[ordenado], nwsmooth, HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, nwsmooth_best_bandwidth)
# Grafico
plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
xlab = "HIP.CIRCUMFERENCE",
ylab = "BUTTOCK.KNEE.LENGTH",
main = "ksmooth vs nwsmooth vs lm",
pch = 19, col = "light blue")
abline(recta_cuad_min, col = "brown", lwd = 2)
lines(HIP.CIRCUMFERENCE[ordenado], nwfit, col = "red", lwd = 3)
lines(ksmoothfit, col = "blue", lwd = 2, lty = 2)
legend("bottomright", legend = c("ksmooth(41)", "nwsmooth(15)", "lm"), col = c("blue", "red", "brown"), lty = c(2,1,1), cex = 0.8, lwd = c(2,3,3))
>>>>>>> Ejercicio-2
