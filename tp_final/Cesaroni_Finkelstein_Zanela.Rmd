---
title: "Estadística - TP Final"
author: "Cesaroni, Finkelstein, Zanela"
date: "2024-07-10"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(1234) 
library(ggplot2)
```

$$
(X_i, Y_i) \sim (X, Y), \quad \text{donde } X, Y \in \mathbb{R} \text{ y } E(Y \mid X = x) = m(x),
$$ con $m: \mathbb{R} \rightarrow \mathbb{R}$ suave, $K$ núcleo que satisface las propiedades a)-e) $h \in \mathbb{R}$ ventana, sea el estimador de Nadaraya–Watson de $m$ dado por $$
\hat{m}_h(x) = \sum_{i=1}^n Y_i \frac{K\left(\frac{X_i - x}{h}\right)}{\sum_{\ell=1}^n K\left(\frac{X_\ell - x}{h}\right)} = \sum_{j=1}^n Y_i w_{i,h}(x). \tag{1}
$$ Llamemos $\mathbf{Y}$ al vector de respuestas con $i$-ésima componente dada por $Y_i$.

$(a)$ $\hat{Y}_i = \hat{m}_h(X_i)$ y sea $\hat{Y}$ el vector de predichos donde la $i$-ésima componente es $\hat{Y}_i$. Queremos ver que $\hat{Y} = SY$, es decir, que se trata de una transformación lineal en $Y$, y hallar una expresión para $S$ definiendo claramente cada una de sus componentes:

Como $$\hat{m}_h(x) = \sum_{j=1}^n Y_i w_{i,h}(x) = $$

$$ \hat{\mathbf{Y}} = 
\begin{pmatrix}
\hat{m}_h(X_1) \\
\hat{m}_h(X_2) \\
\vdots \\
\hat{m}_h(X_n)
\end{pmatrix} =
\begin{pmatrix}
\sum_{j=1}^n Y_i w_{i,h}(X_1) \\
\sum_{j=1}^n Y_i w_{i,h}(X_2) \\
\vdots \\
\sum_{j=1}^n Y_i w_{i,h}(X_n)
\end{pmatrix}
$$

## Ejercicio 2

#### (a)

```{r,echo=TRUE}
individuals <- read.table("individuals.csv", header = TRUE, sep = ";")
datos_femenino <- subset(individuals, SEX == 2 & HIP.CIRCUMFERENCE != 0 & BUTTOCK.KNEE.LENGTH!=0)
attach(datos_femenino)

plot(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH,
     xlab = "HIP.CIRCUMFERENCE",
     ylab = "BUTTOCK.KNEE.LENGTH",
     main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
     pch = 19, col = "blue")
```

Este gráfico sugiere que la longitud del fémur y el perímetro de la cadera están relacionados de forma monotónicamente creciente. Cuanto mayor es la la circunferencia de la cadera, mayor es la longitud del fémur.

#### (b)

```{r}

# Division de grupos etarios por cuartiles
cuartiles <- quantile(datos_femenino$AGE.IN.MONTHS,probs = c(0,0.25, 0.5, 0.75,1))
datos_femenino$AGE.GROUP <- cut(datos_femenino$AGE.IN.MONTHS,cuartiles,include.lowest = TRUE, labels = c("0-81","82-128","129-168","169, +"))

#Estimacion de medianas 
medianas_estimadas <- tapply(datos_femenino$HIP.CIRCUMFERENCE,datos_femenino$AGE.GROUP,median)


# Función para estimación del se de las medianas

estimar_se_mediana <- function (x, B = 1000){
  titahatboot <- rep(0,B)
  for(i in 1:B){
    Xboot <- sample(x,length(x),replace = TRUE)
    titahatboot[i] <- median(Xboot)
  }
  return(sqrt(mean((titahatboot - mean(titahatboot))^2)))
}

# Cálculo de intervalo bootstrap nivel 0.95

intervalos_confianza <- tapply(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$AGE.GROUP, function(x){
  se_boot <- estimar_se_mediana(x)
  intervalo_boot <- c(median(x) - 1.96*se_boot,median(x) + 1.96*se_boot)
  return(intervalo_boot)
})


# Gráfico

# Los siguientes data frames son unicamente creados para generar el plot

df_medianas <- data.frame(
  AGE.GROUP = names(medianas_estimadas),
  MEDIAN = medianas_estimadas
)
df_intervalos <- data.frame(
  AGE.GROUP = names(intervalos_confianza),
  INTERVAL = intervalos_confianza
)
df_intervalos$LOWER <- sapply(df_intervalos$INTERVAL, function(x) x[1])
df_intervalos$UPPER <- sapply(df_intervalos$INTERVAL, function(x) x[2])

df_plot <- merge(datos_femenino,merge(df_medianas,df_intervalos,by="AGE.GROUP"),
                 by="AGE.GROUP")


ggplot(df_plot, aes(x = AGE.GROUP, y = MEDIAN)) +
  geom_point(size = 2) +  
  geom_errorbar(aes(ymin = LOWER, ymax = UPPER), width = 0.2, size = 1) + 
  scale_y_continuous(limits = c(min(df_plot$LOWER) * 0.95, max(df_plot$UPPER)),
                     breaks = seq(from = 600, to = 1000, by = 50)) + 
  labs(title = "Intervalos de Confianza de medianas de HIP.CIRCUMFERENCE\npor grupo etario",
       x = "Grupo Etario", y = "HIP.CIRCUMFERENCE") +
  theme_minimal() + theme(
        plot.title = element_text(hjust = 0.5, face = "bold", size = 14,
                                  margin = margin(10, 0, 10, 0)),  
        axis.title = element_text(size = 14)) 
```

Para calcular los intervalos mencionados, utilizamos el método de intervalo de bootstrap normal. Necesitamos el error estándar de la mediana, el cual obtenemos mediante una estimación bootstrap con la función `estimar_se_mediana`. Esta función realiza un muestreo `B` veces con reposición de HIP.CIRCUMFERENCE y calcula la mediana de estos datos, almacenándolos en un vector. Una vez que tenemos el vector con las `B` medianas calculadas, calculamos el error estándar de la siguiente manera:

$$\sqrt{\frac{1}{n} \sum \left((\hat{se}_{\text{boot}} - \overline{\hat{se}_{\text{boot}}})^2\right)}$$
Y este procedimiento lo hacemos por cada grupo etario.


#### (c)
##### i)

```{r,echo=TRUE}
regresion_100 <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = 100)
regresion_50 <- ksmooth(HIP.CIRCUMFERENCE, BUTTOCK.KNEE.LENGTH, "normal", bandwidth = 50)


plot(datos_femenino$HIP.CIRCUMFERENCE, datos_femenino$BUTTOCK.KNEE.LENGTH,
     xlab = "HIP.CIRCUMFERENCE",
     ylab = "BUTTOCK.KNEE.LENGTH",
     main = "HIP.CIRCUMFERENCE vs. BUTTOCK.KNEE.LENGTH",
     pch = 19, col = "light blue")

lines(regresion_100, col = "red")
lines(regresion_50, col = "purple")

legend("bottomright", legend = c("Ventana 100", "Ventana 50"), col = c("red", "purple"), lty = 1, cex = 0.8)

```
El gráfico muestra que la ventana de 100 suaviza la regresión y es menos sensible a los outliers, mientras que la ventana de 50 ajusta mejor los datos en la parte inferior izquierda, evitando que los valores altos afecten las predicciones de los valores más bajos. Usaríamos la ventana de 50, puesto tiene un mejor ajuste a los datos con valores bajos de HIP.CIRCUMFERENCE y no pareciera estar suficientemente errada en los datos con valores altos de HIP.CIRCUMFERENCE como para que valga más la pena elegir la ventana de 100.

##### ii)
